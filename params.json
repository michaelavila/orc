{"name":"Orc","tagline":"Asynchronous flow control library","body":"# orc\r\n\r\nOrc is designed with one particular goal in mind: to simplify how event driven\r\nprograms are written. The approach orc takes in solving this problem is simpler\r\nand less obtrusive than the [alternatives](https://github.com/caolan/async).\r\nThis is the interface to orc:\r\n\r\n```coffeescript\r\n# run a list of functions one after another\r\n# waiting between functions that require\r\n# some kind of asynchronous handling\r\norc.sequence functions...\r\n\r\n# and in the functions that the sequence calls\r\n# you wrap the callbacks you want to wait for\r\n# with the orc waitFor decorator\r\ncallback = orc.waitFor eventCallback\r\n```\r\n\r\n## Why use it?\r\n\r\nUsing orc should result in programs that avoid two common problems. The first\r\nis created when using the javascript event mechanism directly to express the\r\nasynchronous parts of your program. In this situation the problem is that the\r\nflow of the program jumps from event handler to event handler. This makes the\r\nprogram difficult to understand and work with. The second situation involves\r\nusing something like caolan's [async](https://github.com/caolan/async).\r\nUnfortunately, implementations like this require you to introduce implementation\r\ndetails about how asynchrony is managed into the signature of the asynchronous\r\nmethods.\r\n\r\nSo orc will help you:\r\n\r\n1. clearly and concisely express asynchronous flow control\r\n2. do so without interfering with the API of your module\r\n\r\n## How does it work?\r\n\r\nOrc is a simple beast. A methodical executor, orc orchestrates the execution of\r\nlists of functions. Orc has two execution strategies: one by one or all at once.\r\nThese strategies can be carried out alone, combined, and at the same time. At\r\nany point during the execution orc can be asked to wait so that a more thorough\r\nexecution can take place.\r\n\r\nOrc achieves all of this through the use of some simple data structures and an\r\nexecution context. Execution contexts help orc keep track of what it is\r\nexecuting, the strategy being used to execute, and whether or not orc should\r\nwait before proceeding with the next execution. Orc uses a set of stacks of\r\nqueues to ensure that each execution is carried out at the correct time and in\r\nthe correct order.\r\n\r\nThe condemned functions are placed into queues so that they can be executed in\r\nthe correct order. Each execution context keeps track of a single queue. When\r\na new execution is called for during another execution a new context is created\r\nand stacked on top of the current context. Orc only carries out executions from\r\nthe top of the execution context stacks. When orc is asked to carry out multiple\r\nexecutions at the same time it simply places all of the execution stacks into a\r\nset. That is it: a set of stacks of queues and a context to keep track of extra\r\ninformation associated with each queue.\r\n\r\n## Working Example\r\n\r\nThe following example loads some content, in this case http://google.com, and\r\nthen renders that content in some way.\r\n\r\n```coffeescript\r\norc = require('./lib/orc').orc\r\n\r\nloadData = ->\r\n    console.log 'load the data and wait'\r\n    http = require 'http'\r\n    options =\r\n        host: 'google.com'\r\n        port: 80\r\n        path: ''\r\n\r\n    handleHTTPGet = (response) ->\r\n        response.setEncoding 'utf8'\r\n\r\n        handleData = (chunk) ->\r\n            console.log \"data loaded #{chunk}\"\r\n\r\n        # here we wait as well\r\n        response.on 'data', orc.waitFor(handleData)\r\n\r\n    # here we wait\r\n    http.get options, orc.waitFor(handleHTTPGet)\r\n\r\nrenderPage = ->\r\n    console.log 'now render the page'\r\n\r\n\r\n# this is where we initiate the sequence\r\norc.sequence loadData, renderPage\r\n```\r\n\r\nObviously the important thing here is that the content must complete loading\r\nbefore we proceed to render. I've included some sample code for making an http\r\nrequest in the `loadData` function and `renderPage` simply reports that it was\r\ncalled. I imagine you can fill in the details of what `renderPage` might go on\r\nto do.\r\n\r\nIf you save this example to say `example.coffee` and then run the coffee\r\ninterpreter on it you should see the following:\r\n\r\n```bash\r\n$ coffee example.coffee\r\nload the data and wait\r\ndata loaded <HTML><HEAD><meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\">\r\n<TITLE>301 Moved</TITLE></HEAD><BODY>\r\n<H1>301 Moved</H1>\r\nThe document has moved\r\n<A HREF=\"http://www.google.com/\">here</A>.\r\n</BODY></HTML>\r\n\r\nnow render the page\r\n```\r\n\r\nYou can see that everything was executed in the correct order by inspecting the\r\noutput. The data is loaded and then at the very end it is \"rendered\" (even\r\nthough we aren't technically rendering it.)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}