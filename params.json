{"name":"Orc","tagline":"Asynchronous flow control library","body":"# orc\r\n\r\nIt is customary in computer programming to take a collection of statements that\r\nmight be difficult to understand and place them behind a name, within a\r\nfunction, so that they may be more easily understood and reused. In a language\r\nlike JavaScript if any of these statements are separated by an event then\r\nputting the statements all in one function is very difficult. Orc makes this\r\ntrivial.\r\n\r\nThis problem with asynchrony in JavaScript/CoffeeScript is well-known and best\r\nillustrated with an example. The following programs both do the same thing: 1) \r\nload some content, and then 2) render that content. The first is written\r\nwithout orc:\r\n\r\n```coffeescript\r\nloadData = ->\r\n    console.log 'load the data and wait'\r\n    http = require 'http'\r\n    options =\r\n        host: 'google.com'\r\n        port: 80\r\n        path: ''\r\n\r\n    handleHTTPGet = (response) ->\r\n        response.setEncoding 'utf8'\r\n\r\n        handleData = (chunk) ->\r\n            console.log \"data loaded #{chunk}\"\r\n\r\n        response.on 'data', handleData\r\n\r\n        # here we wait as well\r\n        response.on 'end', renderContent\r\n\r\n    # here we wait\r\n    http.get options, handleHTTPGet\r\n\r\nrenderContent = ->\r\n    console.log 'now render the page'\r\n\r\n\r\n# this is where we initiate the sequence\r\nloadData()\r\n```\r\n\r\nThe overall flow here is:\r\n\r\n1. loadData()\r\n2. renderContent()\r\n\r\nUnderstanding this flow requires reading through the program. It would be\r\nbetter if you could put loadData and renderContent next to eachother:\r\n\r\n```coffeescript\r\norc = require('./src/orc').orc\r\n\r\nloadData = ->\r\n    console.log 'load the data and wait'\r\n    http = require 'http'\r\n    options =\r\n        host: 'google.com'\r\n        port: 80\r\n        path: ''\r\n\r\n    handleHTTPGet = (response) ->\r\n        response.setEncoding 'utf8'\r\n\r\n        handleData = (chunk) ->\r\n            console.log \"data loaded #{chunk}\"\r\n\r\n        response.on 'data', handleData\r\n\r\n        # here we wait as well\r\n        response.on 'end', orc.waitFor()\r\n\r\n    # here we wait\r\n    http.get options, orc.waitFor(handleHTTPGet)\r\n\r\nrenderContent = ->\r\n    console.log 'now render the page'\r\n\r\n\r\n# this is where we initiate the sequence\r\norc.sequence loadData, renderContent\r\n```\r\n\r\nThe important differences are obviously the orc.sequence and two orc.waitFor\r\ncalls. Both of these programs have the same output:\r\n\r\n```bash\r\n$ coffee example.coffee\r\nload the data and wait\r\ndata loaded <HTML><HEAD><meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\">\r\n<TITLE>301 Moved</TITLE></HEAD><BODY>\r\n<H1>301 Moved</H1>\r\nThe document has moved\r\n<A HREF=\"http://www.google.com/\">here</A>.\r\n</BODY></HTML>\r\n\r\nnow render the page\r\n```\r\n\r\nYou can see that first the content is loaded and only after that is the content\r\nrendered.\r\n\r\n## Getting Started\r\n\r\n**1)** Get orc from npm or bower\r\n\r\n```bash\r\n# if you're using with node install with npm\r\nnpm install orc\r\n\r\n# if you're using in the browser install with bower\r\nbower install orc\r\n```\r\n\r\n**2)** Require or script tag orc\r\n\r\n```coffeescript\r\norc = require('orc').orc\r\n```\r\n\r\n```html\r\n<script src=\"orc.js\"></script>\r\n```\r\n\r\n**3)** Sequence some functions\r\n\r\n```coffeescript\r\nloadContent = ->\r\nrenderContent = ->\r\n\r\norc.sequence loadContent, renderContent\r\n```\r\n\r\n**4)** Wait for some stuff\r\n\r\n```coffeescript\r\nloadContent = ->\r\n  request = loader.get someDataUrl\r\n  request.on 'data', orc.waitFor(parseData)\r\n\r\nrenderContent = ->\r\n  animator.do animationOptions orc.waitFor()\r\n\r\norc.sequence loadContent, renderContent\r\n```\r\n\r\n**5)** Tell orc how to error\r\n\r\n```coffeescript\r\nloadContent = ->\r\n  request = loader.get someDataUrl\r\n  request.on 'data', orc.waitFor(parseData)\r\n  request.on 'error', orc.errorOn()\r\n\r\nrenderContent = ->\r\n  animator.do animationOptions orc.waitFor()\r\n\r\norc.sequence loadContent, renderContent\r\n```\r\n\r\n**6)** Handle sequence error instead of erroring\r\n\r\n```coffeescript\r\nloadContent = ->\r\n  request = loader.get someDataUrl\r\n  request.on 'data', orc.waitFor(parseData)\r\n  request.on 'error', orc.errorOn()\r\n\r\nrenderContent = ->\r\n  animator.do animationOptions orc.waitFor()\r\n\r\ncontext = orc.sequence loadContent, renderContent\r\ncontext.handleError = (error, context) -> console.log \"#{error} for #{context}\"\r\n```\r\n\r\nThat's it.\r\n\r\n## How does it work?\r\n\r\nOrc does as much of the bookkeeping as it can. You should almost never need\r\nanything more than the sequence, waitFor, and errorOn functions. Like anything\r\nelse the more you know about orc the easier it is to work with.\r\n\r\n### sequence\r\n\r\nEverything begins with you telling orc to sequence some functions. Orc places\r\nthese condemned functions into an ExecutionContext. The context lets orc keep\r\nthe details of each execution separated. These details are things like the\r\nfunctions being executed and whether or not the execution is on hold for\r\nanything. At this point orc will begin executing, if it's not already.\r\n\r\nOrc can execute both dependent and independent sequences. A sequence is dependent\r\nwhen it requires another sequence to complete before it completes. Dependent\r\nsequences are called inside of other sequences kinda like this:\r\n\r\n```coffeescript\r\norc.sequence ->\r\n  orc.sequence ...\r\n```\r\n\r\nIndependent sequences on the other hand look kinda like this:\r\n\r\n```coffeescript\r\norc.sequence ...\r\norc.sequence ...\r\n```\r\n\r\nWhether or not one sequence depends on another sequence determines where orc\r\nputs the execution context. If the sequence is independent orc will add it\r\nalongside whatever other contexts exist. If the sequence is dependent orc\r\nwill stack the context on top of whichever context depends on it. Orc then\r\nmanages these dependencies by only executing from the context at the top of of\r\neach stack.\r\n\r\n### waitFor\r\n\r\nThe waitFor decorator is simple. First it saves the current context so that\r\nlater on it can determine which context the decorated function belongs to. Then\r\nit returns a function that wraps the callback it was provided.\r\n\r\nThe decorated function that waitFor returns will set the current context to the\r\ncontext that was saved earlier. This ensures that any waitFor calls made during\r\nthe callback will be routed to the correct context. At the very end, once it\r\nhas executed the callback, the waitFor function will call done on the correct\r\ncontext.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}