{"name":"Orc","tagline":"Asynchronous flow control library","body":"# orc\r\n\r\nOrc orchestrates the execution of lists of functions. This library will help you:\r\n\r\n1. clearly and concisely express asynchronous flow\r\n2. do so without polluting your API\r\n\r\n## Getting Started\r\n\r\n**1)** Get orc from npm or bower\r\n\r\n```bash\r\n# if you're using with node install with npm\r\nnpm install orc\r\n\r\n# if you're using in the browser install with bower\r\nbower install orc\r\n```\r\n\r\n**2)** Require or script tag orc\r\n\r\n```coffeescript\r\norc = require('orc').orc\r\n```\r\n\r\n```html\r\n<script src=\"orc.js\"></script>\r\n```\r\n\r\n**3)** Sequence some functions\r\n\r\n```coffeescript\r\nloadContent = ->\r\nrenderContent = ->\r\n\r\norc.sequence loadContent, renderContent\r\n```\r\n\r\n**4)** Wait for some stuff\r\n\r\n```coffeescript\r\nloadContent = ->\r\n  request = loader.get someDataUrl\r\n  request.on 'data', orc.waitFor(parseData)\r\n\r\nrenderContent = ->\r\n  animator.do animationOptions orc.waitFor()\r\n\r\norc.sequence loadContent, renderContent\r\n```\r\n\r\n**5)** Tell orc how to error\r\n\r\n```coffeescript\r\nloadContent = ->\r\n  request = loader.get someDataUrl\r\n  request.on 'data', orc.waitFor(parseData)\r\n  request.on 'error', orc.errorOn()\r\n\r\nrenderContent = ->\r\n  animator.do animationOptions orc.waitFor()\r\n\r\norc.sequence loadContent, renderContent\r\n```\r\n\r\n**6)** Handle sequence error instead of erroring\r\n\r\n```coffeescript\r\nloadContent = ->\r\n  request = loader.get someDataUrl\r\n  request.on 'data', orc.waitFor(parseData)\r\n  request.on 'error', orc.errorOn()\r\n\r\nrenderContent = ->\r\n  animator.do animationOptions orc.waitFor()\r\n\r\ncontext = orc.sequence loadContent, renderContent\r\ncontext.handleError = (error, context) -> console.log \"#{error} for #{context}\"\r\n```\r\n\r\nThat's it.\r\n\r\n## Working Example\r\n\r\nThe following example is typical: make an HTTP request for some content and\r\nrender that content in some way once we receive it. Here we tell orc to\r\nsequence the two functions loadData and renderPage. In the loadData function we\r\ntell orc to waitFor a response and then to wait for the data to finish loading.\r\nThe renderPage function just logs \"now render the page\" to the console.\r\n\r\n```coffeescript\r\norc = require('./lib/orc').orc\r\n\r\nloadData = ->\r\n    console.log 'load the data and wait'\r\n    http = require 'http'\r\n    options =\r\n        host: 'google.com'\r\n        port: 80\r\n        path: ''\r\n\r\n    handleHTTPGet = (response) ->\r\n        response.setEncoding 'utf8'\r\n\r\n        handleData = (chunk) ->\r\n            console.log \"data loaded #{chunk}\"\r\n\r\n        response.on 'data', handleData\r\n\r\n        # here we wait as well\r\n        response.on 'end', orc.waitFor()\r\n\r\n    # here we wait\r\n    http.get options, orc.waitFor(handleHTTPGet)\r\n\r\nrenderPage = ->\r\n    console.log 'now render the page'\r\n\r\n\r\n# this is where we initiate the sequence\r\norc.sequence loadData, renderPage\r\n```\r\n\r\nIf you run the example you will see that everything is called in the correct\r\norder. The renderPage function does not run until we have received all of the\r\ndata from the loadData function. I've listed the output below:\r\n\r\n```bash\r\n$ coffee example.coffee\r\nload the data and wait\r\ndata loaded <HTML><HEAD><meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\">\r\n<TITLE>301 Moved</TITLE></HEAD><BODY>\r\n<H1>301 Moved</H1>\r\nThe document has moved\r\n<A HREF=\"http://www.google.com/\">here</A>.\r\n</BODY></HTML>\r\n\r\nnow render the page\r\n```\r\n\r\n## How does it work?\r\n\r\nOrc does as much of the bookkeeping as it can. You should almost never need\r\nanything more than the sequence, waitFor, and errorOn functions. Like anything\r\nelse the more you know about orc the easier it is to work with.\r\n\r\n### sequence\r\n\r\nEverything begins with you telling orc to sequence some functions. Orc places\r\nthese condemned functions into an ExecutionContext. The context lets orc keep\r\nthe details of each execution separated. These details are things like the\r\nfunctions being executed and whether or not the execution is on hold for\r\nanything. At this point orc will begin executing, if it's not already.\r\n\r\nOrc can execute both dependent and independent sequences. A sequence is dependent\r\nwhen it requires another sequence to complete before it completes. Dependent\r\nsequences are called inside of other sequences kinda like this:\r\n\r\n```coffeescript\r\norc.sequence ->\r\n  orc.sequence ...\r\n```\r\n\r\nIndependent sequences on the other hand look kinda like this:\r\n\r\n```coffeescript\r\norc.sequence ...\r\norc.sequence ...\r\n```\r\n\r\nWhether or not one sequence depends on another sequence determines where orc\r\nputs the execution context. If the sequence is independent orc will add it\r\nalongside whatever other contexts exist. If the sequence is dependent orc\r\nwill stack the context on top of whichever context depends on it. Orc then\r\nmanages these dependencies by only executing from the context at the top of of\r\neach stack.\r\n\r\n### waitFor\r\n\r\nThe waitFor decorator is simple. First it saves the current context so that\r\nlater on it can determine which context the decorated function belongs to. Then\r\nit returns a function that wraps the callback it was provided.\r\n\r\nThe decorated function that waitFor returns will set the current context to the\r\ncontext that was saved earlier. This ensures that any waitFor calls made during\r\nthe callback will be routed to the correct context. At the very end, once it\r\nhas executed the callback, the waitFor function will call done on the correct\r\ncontext.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}